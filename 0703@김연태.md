## 0703

#### 데일리 미팅

- 어제 무슨일을 했는지
- 오늘 무슨 일을 할 것인지 
- 업무를 하면서 발생한 이슈 공유
- 시간은 15분 이내로 짧게



#### 오늘의 데일리 미팅

- 어제 첫째날을 보내면서 느낀 점
- 어제 짝 프로그래밍을 하면서 느낀점
- 결정할 사항 - 자리 배치는 어떻게 할 것인지?



오늘의 페어프로그래밍 진행

- 드라이버 진행은 10분 
- 10분뒤에 끊고 이야기하는 시간을 갖기
- 생각나는게 있으면 주석등으로 처리하기
- 미션 완수하는 것보다 서로 이야기 많이할 수 있는 방향으로
- 테스트코드 잊지않고 짜기 



## 강의내용

### 코딩컨벤션

나의 개성을 코드에 드러내면 다른사람이 읽기가 힘들어진다.

코드스타일의 차이로 사소한 감정싸움이 일어나고 시간이 지연될 수 있다. 

**현장에선 상당히 중요하다**

처음엔 자바의 코딩컨벤션에 맞게 작성했느냐?로 피드백 많이 할 예정

**자바의 기본 코딩컨벤션을 따르는것을 원칙으로 하겠다**

</br>

##### 가로 format 맞추기

120까지

</br>

#### Naming Convention

- 자바는 카멜케이스를 따른다. 
- 클래스명은 대문자로 시작, 변수 메소드는 소문자로 시작
- 패키지명은 소문자로 시작, 근데 카멜케이스 적용안되는게 좋음. 따라서 한단어로 만들라.
- 정 불가능하면 . 으로 구분하라. Ex) string.calculator.parser ...
- 클래스 이름 예 : Rectangle....
- 변수 이름 예 : firstName...
- 메소드 이름 예 : getFirstName()
- 패키지 이름 예 :  calculator

**이름을 어떻게 짓느냐에 따라 구현이 달라진다!!**

</br>

#### 팀규칙

- 팀에 속한다면 자신이 선호해야 할 규칙은 팀 규칙이다. 
- 팀은 한가지 규칙에 합의하고 모든 팀원이 따라야 한다. 
- 이를 따르지 않는다는 것은 팀에 해를 끼친다는 뜻이다. 

</br>

#### 자바 기본 컨벤션을 알고싶다면

- Intelli J 에서 Alt + Command + L (Reformat) - 자동포맷팅 해준다. 

</br>

#### 사소하지만 중요한 자바의 컨벤션들

- if 문의 ()와 {}사이를 한칸 띄우는것도 컨벤션이다.
- 의미없는 공백(스페이스, 엔터..)를 만들지 않는다. 

</br>

</br>

### 함수(메소드) CleanCode Guide

​	자바에 국한된게 아니라 모든 언어에 해당되는 이야기이다. 

​	메소드 분리만 잘되도 깔끔한 코드가 나온다. 

​	정답이 있는건 아니고 끊임없는 연습이 필요하다. 

</br>

#### 작게 만들어라. 

​	함수를 만드는 첫번째 규칙은 **'작게'**이다. 함수를 만드는 두번째 규칙은 **'더 작게'**이다. 

​	메소드를 작게 분리해서 일어나는 약간의 성능하락은 하드웨어의 발전으로 크게 신경쓸 필요 없어졌다. 

​	하드웨어보다 사람의 몸값이 훨씬 비싸다. 유지보수의 편의성이 훨씬 중요하다. 

</br>

#### 한가지 일만 하라. 

​	메소드는 한가지를 해야하고 한가지를 잘해야 한다. 

​	메소드를 설계하는데 있어 중요한 것.

</br>

#### 함수당 추상화 수준은 하나로

​	함수가 확실히 한가지 작업만 하려면 함수 내 모든 문장이 동일한 추상화 수준에 있어야 한다. 

​	코드는 위에서 아래로 이야기처럼 일해야 좋다.

</br>

#### 서술적인 이름을 사용하라

​	이름이 길어도 괜찮다.

​	이름만으로 메소드가 하는 일을 드러낼 수 있도록 하라. 

​	이름을 붙일 때는 일관성이 있어야 한다. 

##### 	근데 메소드 이름이 길어진다는 것은 메소드가 여러가지 일을 할 가능성이 높다. => 메소드 분리를 고려하라. 

</br>

#### 함수 인수

​	함수에서 이상적인 인수 개수는 0개이다. 다음은 1개, 2개.. 

​	3개는 가능한 피하는 편이 좋다. 

##### 	4개 이상은 특별한 이유가 있어도 무조건 피하라!!

``` Java
Circle makeCircle(double x, double y, double radius);
// 위와 같이 3개의 인수를 같는 메소드를
Circle makeCircle(Point center, double radius);
// 이렇게 적절한 클래스를 사용한다면 2개로 줄일 수 있다. 
```

</br>

#### Side Effect를 만들지 말라. 

</br>

#### 명령과 조회를 분리하라. 

</br>

#### 반복하지 마라. 

​	중복코드는 소프트웨어에서 모든 악의 근원이다. 

</br>

</br>

#### 테스트는 귀찮지만 배포에 대한 안정성을 높이는 중요한 장치이다!!

</br>

</br>

</br>

### 테스트하기 쉬운 코드란?

- 테스트 장애물이 적은 코드
- 어떻게 해야 테스트하기 쉬운 코드를 만들 수 있을까?

</br>

#### 테스트하기 어려운 코드 

- private으로 선언되어 외부에서 확인할 방법이 없을때
- 랜덤넘버가 돌아서 외부에서 값을 정해줄 수 없을때
- 바로 프린트를 해버리는 등 사이드 이펙트를 만들때

</br>

#### 불확실성(non - deterministric) - 외부 세상에서 값을 읽어 오는 것과 관련

- 랜덤수 / 임의시각
- 전역변수
- 로컬 머신에 존재하는 파일 내용
- DB의 특정 레코드
- HTTP - GET (외부서버가 다운되면 FAIL)

</br>

#### 부수효과(side-effect) - 외부 세상에 값을 기록하는 것과 관련

- 전역변수
- 로컬 머신에 존재하는 파일 내용
- DB의 특정 레코드
- HTTP - POST

</br>

#### 테스트하기 쉬운 코드를 만들려면?

##### 순수함수

- 불확실성과 부수효과가 없는 함수를 순수함수라 함
- 순수 함수로 구현하는 것이 테스트하기 쉬운 코드

##### 반환값

- 반환 값이 없는 경우보다 반환 값이 있는 경우가 테스트하기 쉬운 코드

</br>

#### 테스트하기 쉬운 코드로 개발하려면...

- 테스트하기 쉬운 코드와 테스트하기 어려운 코드가 공존하는 것이 현실
- 테스트하기 쉬운 코드와 테스트하기 어려운 코드를 최대한 분리해야 한다. 
- 처음엔 테스트하기 쉬운 코드부터 테스트를 진행한다. 
- 테스트하기 쉬운 코드와 어려운 코드를 구분하는 눈을 키워야 한다. 
- 테스트하기 어려운 메소드는 테스트가 가능한 부분까지만 잘라서 새로운 메소드를 만든다. 



```Java
// 1. 테스트하기 어려운 원본코드 
public void move(){
    if(getRandomNum()>= 4)
        this.position++;
}
// 2. 랜덤넘버를 밖에서 받아옴
public void move(int randomNum){
    if(randomNum>= 4)
        this.position++;
}
// 3. 테스트를 위해 리턴값 생성
public int move(int randomNum){
    if(randomNum>= 4)
        this.position++;
    //else를 쓰지 않는 예이다. 이경우에 걸려버리면 바로 리턴함.
    return this.position;
}

//4. 매우 안좋은 코드, 이렇게 안할거 같지만 너도 예외는 아니다..
public int move(int randomNum){
    int p = 0;
    if(randomNum>= 4)
        p = this.position++;
    else
        p = this.position;
    return p;
}
```

